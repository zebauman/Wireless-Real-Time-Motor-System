# =============================================================================
# prj.conf — STM32WB55 BLDC Motor Controller
#
# The STM32WB55 is a DUAL-CORE chip:
#   Cortex-M4  @ 64 MHz — runs this Zephyr application (motor + BLE host)
#   Cortex-M0+ @ 32 MHz — runs the ST BLE coprocessor firmware (HCI layer)
#
# BLE on the WB55 works completely differently from a single-core STM32:
#   - The M0+ handles all RF/PHY/LL work via ST's closed-source coprocessor binary
#   - The M4 (Zephyr) talks to the M0+ over IPCC (inter-processor communication)
#   - Zephyr uses the CONFIG_BT_STM32_IPM driver for this — NOT a software stack
#   - CONFIG_BT_LL_SW_SPLIT must NOT be set (that's for chips with no coprocessor)
#
# CRITICAL HARDWARE STEP before this firmware will work:
#   Flash the M0+ coprocessor with the HCI-only binary from STM32CubeWB:
#   File: stm32wb5x_BLE_HCILayer_extended_fw.bin   (use "extended" variant)
#   Tool: STM32CubeProgrammer → Firmware Upgrade Services
#   Address: see hal_stm32/lib/stm32wb/README.rst for exact flash address
#   WARNING: Since STM32CubeWB V1.13.2, "Full Stack" binaries are NOT
#            compatible with Zephyr. Use HCI Layer only.
# =============================================================================

# =============================================================================
# SYSTEM
# =============================================================================
CONFIG_MAIN_STACK_SIZE=4096
CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE=2048

# Minimal libc is sufficient — printf replaced with LOG_DBG throughout
CONFIG_MINIMAL_LIBC=y

# FPU: WB55 Cortex-M4 has hardware FPU — enable it for float PID math
CONFIG_FPU=y
CONFIG_FPU_SHARING=y

# =============================================================================
# BLUETOOTH — STM32WB55 IPM (inter-processor mailbox) driver
#
# On the WB55 the board DTS already selects CONFIG_BT_STM32_IPM automatically
# when CONFIG_BT=y. These settings below configure the host layer on the M4.
# =============================================================================
CONFIG_BT=y
CONFIG_BT_PERIPHERAL=y
CONFIG_BT_DEVICE_NAME="MOTORSRV"

# DO NOT enable CONFIG_BT_LL_SW_SPLIT — that enables a software BLE controller
# which conflicts with the WB55's hardware M0+ coprocessor via IPM.

# Extended advertising not needed for a simple connectable peripheral
CONFIG_BT_EXT_ADV=n

# Let the stack negotiate optimal connection parameters after linking
CONFIG_BT_GAP_AUTO_UPDATE_CONN_PARAMS=y

# Increase RX buffer count — the IPM transport can burst multiple packets
# before the M4 processes them; default of 3 can cause drops under load
CONFIG_BT_BUF_ACL_RX_COUNT=6

# ATT prepare queue — needed for reliable multi-packet GATT writes
CONFIG_BT_ATT_PREPARE_COUNT=2

# IPCC mailbox driver (automatically selected by board DTS, listed for clarity)
# CONFIG_IPM=y                    ← set by board
# CONFIG_IPM_STM32_HSEM=y         ← set by board
# CONFIG_BT_STM32_IPM=y           ← set by board

# =============================================================================
# HARDWARE PERIPHERALS
# =============================================================================
CONFIG_GPIO=y
CONFIG_PINCTRL=y
CONFIG_HWINFO=y          # Used in bluetooth.c for unique device ID in MSD

# PWM node declared in overlay for pin mux only; LL API drives TIM1 directly
CONFIG_PWM=y
CONFIG_PWM_STM32=y

# ADC not used — re-enable with CONFIG_ADC_STM32=y if current sensing is added
# CONFIG_ADC=y

# =============================================================================
# SERIAL CONSOLE
# USART1 on PA9/PA10 is the default console on WB55 boards.
# Note: PA9/PA10 are also TIM1_CH2/CH3. If you're using USART1 for debug,
# move your PWM outputs or your console UART to different pins.
# =============================================================================
CONFIG_SERIAL=y
CONFIG_CONSOLE=y
CONFIG_UART_CONSOLE=y
CONFIG_STDOUT_CONSOLE=y

# =============================================================================
# LOGGING
# =============================================================================
CONFIG_LOG=y
CONFIG_LOG_BACKEND_UART=y

# CRITICAL: Deferred mode — log calls return immediately, background thread
# does the UART work. Without this, LOG_x() in the 100Hz PID loop blocks
# inline and destroys control timing.
CONFIG_LOG_MODE_DEFERRED=y

# 4KB buffer: holds queued messages from PID thread (3 logs/cycle @ 100Hz)
# plus BLE connection events. 2KB is too small and drops messages.
CONFIG_LOG_BUFFER_SIZE=4096

CONFIG_LOG_PRINTK=y
CONFIG_PRINTK=y

# 0=off  1=error  2=warn  3=info  4=debug
CONFIG_LOG_DEFAULT_LEVEL=3

# Per-module overrides — uncomment to debug specific subsystems:
# CONFIG_BT_LOG_LEVEL=2
# CONFIG_LOG_OVERRIDE_LEVEL=4    # forces all modules to debug (very verbose)

# =============================================================================
# DEVELOPMENT / DEBUG — disable before production release
# =============================================================================

# Stack canary: panics with a clear message on overflow instead of silent
# memory corruption. Essential during development on all threads.
CONFIG_STACK_SENTINEL=y

# Thread analyzer: shows high-water stack usage per thread.
# Run once to verify STACK_SIZE values, then disable.
# CONFIG_THREAD_ANALYZER=y
# CONFIG_THREAD_ANALYZER_AUTO=y
# CONFIG_THREAD_ANALYZER_AUTO_INTERVAL=30

# Hardware watchdog — feeds independently of BLE watchdog; resets the
# entire chip if ANY thread hangs (PID, telemetry, or BLE host thread)
# CONFIG_WATCHDOG=y
# CONFIG_WDT_DISABLE_AT_BOOT=n